extern crate png;

use std::{path::Path, fs::File, io::BufWriter, time::Instant};
use png::Encoder;

// width must be a multiple of 64 or 32 on 64-bit or 32-bit machines respectively
const W: usize = 2048;
// height must be less than or equal to width, and even
const H: usize = 2048;
// set to a square for best results!


fn generate_sierpinski(buf: &mut [u8]) {
    // Challenge: generate an image of sierpinski's triangle
    // very fast and such that it can be directly written to
    // a file using the `png` crate

    // Method: Sierpinski's triangle can be generated by taking Pascal's 
    // triangle and coloring in all of the odd numbers. In order to determine
    // whether (n k) is odd or even, we only need to know if (n-1 k) and (n-1 k-1)
    // are odd or even. We can track this all with a single bit per entry in the
    // triangle, with direct correspondence to the pixels. Simply "add" every pixel 
    // with it's neighbor, where addition merely applies the rule that the oddness 
    // of the added values XOR'd is the oddness of the result. This allows us to 
    // compute (n choose k % 2) indefinitely without the trouble of factorials blowing up.

    // Results: Pretty good! It's not quite equilateral for the sake of the fun 
    // binary tricks (it's 1:2), but who's putting a ruler up to their screen and checking? :)

    // Acknowledgements: 
    // - An applied maths lecturer I will miss, for prompting me to give this a shot.
    // - https://upload.wikimedia.org/wikipedia/commons/8/87/Sierpinski_Pascal_triangle.svg

    const SZ: usize = std::mem::size_of::<usize>() * 8;

    debug_assert!(buf.len() % SZ == 0, "Error: Width is not divisible by the word size, {}.", SZ);
    debug_assert!(H % 2 == 0, "Error: Height is not even.");
    debug_assert!(W >= H, "Error: Height must not be greater than width.");

    // switch to word-size data chunks
    // this allows for shifting a lot more bits per instruction,
    // but reverses the endianness contrary to png's expectations 
    // on little endian systems
    let buf: &mut [usize] = unsafe {
        std::slice::from_raw_parts_mut(buf.as_mut_ptr() as _, buf.len()*8/SZ)
    };

    // half of width, add the start pixel on the first row
    buf[W / 2 / SZ - 1] = 1;
    
    let mut prev_row = 0;
    let mut row = W / SZ;

    loop {
        // don't operate on more of the row than necessary
        let left  = (W/SZ/2) - row / W / 2 - 1;
        let right = (W/SZ/2) + row / W / 2;

        // xor the above row with itself shifted right
        let mut carry = 0;
        for word in left..=right {
            let row_above = buf[prev_row + word];
            let next_carry = (row_above & 1) << (SZ - 1);
            buf[row + word] = row_above ^ ((row_above >> 1) | carry);
            carry = next_carry;
        }
        
        // do the next row, but check if we've hit the height limit first
        row += W/SZ;
        prev_row += W/SZ;
        if row == W * H / SZ { break; }

        let left  = (W/SZ/2) - row / W / 2 - 1;
        // xor the above row with the row shifted left
        let mut carry = 0;
        for word in (left..=right).rev() {
            let row_above = buf[prev_row + word];
            let (shiftd_row_above, next_carry) = row_above.overflowing_add(row_above);
            buf[row + word] = row_above ^ (shiftd_row_above | carry);
            carry = next_carry as _;
        }

        row += W/SZ;
        prev_row += W/SZ;
    }

    // fix the endianness of the data
    buf.iter_mut().for_each(|d| *d = d.to_be());
}


fn main() {
    // allocate zeroed data buffer to write to
    let mut data = vec![0; W / 8 * H];
    // warm up the caches, make sure we didn't get a bunch of COW mem pages, etc.
    data.iter_mut().for_each(|d| unsafe { std::ptr::write_volatile(d, 0) });

    // generate sierpinski's triangle
    let start = Instant::now();
    generate_sierpinski(&mut data);
    let end = Instant::now();
    
    // print the performance measurement
    let duration = end - start;
    println!("Generation speed: {} us", duration.as_secs_f64() * 1e6);
    

    // save the result to out.png

    let path = Path::new(r"out.png");
    let file = File::create(path).unwrap();
    let ref mut w = BufWriter::new(file);

    let mut encoder = Encoder::new(w, W as u32, H as u32);
    encoder.set_color(png::ColorType::Grayscale);
    encoder.set_depth(png::BitDepth::One);

    let mut writer = encoder.write_header().unwrap();
    writer.write_image_data(&data).unwrap();
}
